diff --git a/plugin.video.otaku.testing/resources/lib/WatchlistFlavor/Kitsu.py b/plugin.video.otaku.testing/resources/lib/WatchlistFlavor/Kitsu.py
index 8ee3757e276aa96629d14ee0904c06e95bade5c0..9f0235d481f6c7be4b9af3d3ed84dd809f9f1367 100644
--- a/plugin.video.otaku.testing/resources/lib/WatchlistFlavor/Kitsu.py
+++ b/plugin.video.otaku.testing/resources/lib/WatchlistFlavor/Kitsu.py
@@ -45,52 +45,51 @@ class KitsuWLF(WatchlistFlavorBase):
 
         login_data = {
             'username': data2["attributes"]["name"],
             'userid': data2['id'],
             'token': data['access_token'],
             'refresh': data['refresh_token'],
             'expiry': int(time.time()) + int(data['expires_in'])
         }
         return login_data
 
     def refresh_token(self):
         params = {
             "grant_type": "refresh_token",
             "refresh_token": control.getSetting('kitsu.refresh')
         }
         resp = client.request(f'{self._URL}/oauth/token', post=params, jpost=True)
 
         if not resp:
             return
 
         data = json.loads(resp)
         control.setSetting('kitsu.token', data['access_token'])
         control.setSetting('kitsu.refresh', data['refresh_token'])
         control.setInt('kitsu.expiry', int(time.time() + int(data['expires_in'])))
 
-    @staticmethod
-    def handle_paging(hasnextpage, base_url, page):
+    def handle_paging(self, hasnextpage, base_url, page):
         if not hasnextpage or not control.is_addon_visible() and control.getBool('widget.hide.nextpage'):
             return []
         next_page = page + 1
         name = "Next Page (%d)" % next_page
         parsed = parse.urlparse(hasnextpage)
         offset = parse.parse_qs(parsed.query)['page[offset]'][0]
         return [utils.allocate_item(name, f'{base_url}/{offset}?page={next_page}', True, False, [], 'next.png', {'plot': name}, fanart='next.png')]
 
     def __get_sort(self):
         # Mapping:
         # 0: Anime Title -> sort by anime.titles.{language} alphabetically
         # 1: Score -> sort by anime.averageRating descending
         # 2: Progress -> sort by progress descending
         # 3: Last Updated -> sort by progressed_at descending
         # 4: Last Added -> sort by started_at descending
         sort_options = [
             f"anime.titles.{self.__get_title_lang()}",
             "-anime.averageRating",
             "progress",
             "-progressed_at",
             "-started_at",
         ]
         return sort_options[int(self.sort)]
 
     def __get_title_lang(self):
diff --git a/plugin.video.otaku.testing/resources/lib/WatchlistFlavor/MyAnimeList.py b/plugin.video.otaku.testing/resources/lib/WatchlistFlavor/MyAnimeList.py
index 31efa6f80895d219e8e0084ff2e6d9264894d43c..01e7afde2833fce694ad40aeba674aa4561339bc 100644
--- a/plugin.video.otaku.testing/resources/lib/WatchlistFlavor/MyAnimeList.py
+++ b/plugin.video.otaku.testing/resources/lib/WatchlistFlavor/MyAnimeList.py
@@ -54,52 +54,51 @@ class MyAnimeListWLF(WatchlistFlavorBase):
             'refresh': res['refresh_token'],
             'expiry': int(time.time()) + int(res['expires_in']),
             'username': user['name']
         }
         return login_data
 
     @staticmethod
     def refresh_token():
         oauth_url = 'https://myanimelist.net/v1/oauth2/token'
         api_info = database.get_info('MyAnimeList')
         client_id = api_info['client_id']
 
         data = {
             'client_id': client_id,
             'grant_type': 'refresh_token',
             'refresh_token': control.getSetting('mal.refresh')
         }
         r = client.request(oauth_url, post=data)
         if not r:
             return
         res = json.loads(r)
         control.setSetting('mal.token', res['access_token'])
         control.setSetting('mal.refresh', res['refresh_token'])
         control.setInt('mal.expiry', int(time.time()) + int(res['expires_in']))
 
-    @staticmethod
-    def handle_paging(hasnextpage, base_url, page):
+    def handle_paging(self, hasnextpage, base_url, page):
         if not hasnextpage or not control.is_addon_visible() and control.getBool('widget.hide.nextpage'):
             return []
         next_page = page + 1
         name = "Next Page (%d)" % next_page
         offset = (re.compile("offset=(.+?)&").findall(hasnextpage))[0]
         return [utils.allocate_item(name, f'{base_url}/{offset}?page={next_page}', True, False, [], 'next.png', {'plot': name}, fanart='next.png')]
 
     def __get_sort(self):
         sort_types = ['anime_title', 'list_score', "", 'list_updated_at', 'anime_start_date']
         return sort_types[int(self.sort)]
 
     def watchlist(self):
         statuses = [
             ("Next Up", "watching?next_up=true", 'next_up.png'),
             ("Currently Watching", "watching", 'currently_watching.png'),
             ("Completed", "completed", 'completed.png'),
             ("On Hold", "on_hold", 'on_hold.png'),
             ("Dropped", "dropped", 'dropped.png'),
             ("Plan to Watch", "plan_to_watch", 'want_to_watch.png'),
             ("All Anime", "", 'all_anime.png')
         ]
         return [utils.allocate_item(res[0], f'watchlist_status_type/{self._NAME}/{res[1]}', True, False, [], res[2], {}) for res in statuses]
 
     @staticmethod
     def action_statuses():
diff --git a/plugin.video.otaku.testing/resources/lib/ui/BrowserBase.py b/plugin.video.otaku.testing/resources/lib/ui/BrowserBase.py
index ad7f8beff6ce12e95cfe549078e19c2677f0e980..f918295bc738658e72fc186b887a315ca73de935 100644
--- a/plugin.video.otaku.testing/resources/lib/ui/BrowserBase.py
+++ b/plugin.video.otaku.testing/resources/lib/ui/BrowserBase.py
@@ -1,43 +1,53 @@
 # -*- coding: utf-8 -*-
 import base64
 import re
 import urllib.parse
 
 from resources.lib.ui import client, control, utils
 
 
 class BrowserBase(object):
     _BASE_URL = None
 
-    @staticmethod
-    def handle_paging(hasnextpage, base_url, page):
+    def set_current_path(self, path):
+        self._current_path = path
+
+    def handle_paging(self, hasnextpage, base_url, page):
         if not hasnextpage or not control.is_addon_visible() and control.getBool('widget.hide.nextpage'):
             return []
         next_page = page + 1
         name = "Next Page (%d)" % next_page
-        return [utils.allocate_item(name, base_url % next_page, True, False, [], 'next.png', {'plot': name}, 'next.png')]
+        url = base_url % next_page
+        plugin_path = getattr(self, '_current_path', None)
+        if plugin_path:
+            if '?' in url:
+                _, query = url.split('?', 1)
+                url = f'{plugin_path}?{query}'
+            else:
+                url = plugin_path
+        return [utils.allocate_item(name, url, True, False, [], 'next.png', {'plot': name}, 'next.png')]
 
     @staticmethod
     def open_completed():
         import json
         try:
             with open(control.completed_json) as file:
                 completed = json.load(file)
         except FileNotFoundError:
             completed = {}
         return completed
 
     @staticmethod
     def duration_to_seconds(duration_str):
         # Regular expressions to match hours, minutes, and seconds
         hours_pattern = re.compile(r'(\d+)\s*hr')
         minutes_pattern = re.compile(r'(\d+)\s*min')
         seconds_pattern = re.compile(r'(\d+)\s*sec')
 
         # Extract hours, minutes, and seconds
         hours_match = hours_pattern.search(duration_str)
         minutes_match = minutes_pattern.search(duration_str)
         seconds_match = seconds_pattern.search(duration_str)
 
         # Convert to integers, default to 0 if not found
         hours = int(hours_match.group(1)) if hours_match else 0
diff --git a/plugin.video.otaku.testing/resources/lib/ui/router.py b/plugin.video.otaku.testing/resources/lib/ui/router.py
index a997fad4a1b6fdfa2984e59163e9c498af5d54b0..115f2a595c670452eb56fedbd6b6c8d41aba1f5d 100644
--- a/plugin.video.otaku.testing/resources/lib/ui/router.py
+++ b/plugin.video.otaku.testing/resources/lib/ui/router.py
@@ -1,24 +1,26 @@
 ROUTES = []
 
 
 class Route:
     def __init__(self, route_path):
         self.path = route_path
         self.wildcard = False
         if route_path.endswith("*"):
             self.wildcard = True
             self.path = route_path[:-1]
 
     def __call__(self, func):
         self.func = func
         ROUTES.append(self)
         return func
 
 
 def router_process(url, params=None):
     if not params:
         params = {}
+    from resources.lib import OtakuBrowser
+    OtakuBrowser.BROWSER.set_current_path(url)
     payload = "/".join(url.split("/")[1:])
     for route_obj in ROUTES:
         if url == route_obj.path or (route_obj.wildcard and url.startswith(route_obj.path)):
             return route_obj.func(payload, params)
